# API 

В качестве примера хорошего и несложного API, созданного по принципам REST, 
рассмотрим сервис [SWAPI — Star Wars API](https://swapi.dev/).

## RESTful API 

Принципы REST
Эти принципы ввёл Рой Филдинг в 2000 году в своей диссертации «Архитектурные стили и дизайн сетевых программных структур».
1. Клиент-сервер. Разделение ответственности между клиентом и сервером
Клиент и сервер отвечают за разные вещи. Ответственность клиента — пользовательский интерфейс, ответственность сервера — данные. Если API возвращает HTML-страницу, его нельзя назвать REST API: ведь при этом сервер берёт на себя ответственность за интерфейс.
2. Отсутствие состояния. Сервер не хранит состояние
Каждый запрос должен быть независимым, как будто он сделан в первый раз. Сервер не должен хранить какой-либо информации о клиенте. Каждый запрос клиента к серверу должен содержать всю информацию, необходимую для обработки этого запроса: кто запрашивает данные, какие данные запрашиваются.
3. Единый интерфейс
Интерфейс обращения к серверу одинаков для всех и не зависит от клиента. Запрос к данным может быть сформирован из браузера, мобильного приложения и с «умного» чайника по одним и тем же правилам.
4. Многоуровневость
Первый принцип гласит, что в коммуникации участвуют двое: клиент и сервер. Но можно строить более сложные системы, не нарушая этого принципа.
API сервиса Яндекс.Такси может использовать API Яндекс.Навигатора. Вы как клиент взаимодействуете только с API Яндекс.Такси, а он, в свою очередь, является клиентом навигатора. Здесь есть одно условие — каждый компонент должен видеть только свой уровень. Например, Яндекс.Навигатор не должен видеть все данные, которые вы отправили в Яндекс.Такси.
5. Кешируемость
Данные ответа могут быть закешированы. Это значит, что можно сохранить полученные данные на клиенте, а при идентичном запросе взять их из памяти клиента — кеша, а не ждать их с сервера. Нет смысла запрашивать данные повторно, если они никак не изменились.
6. Код по запросу
Этот принцип необязательный. Он гласит, что функциональность клиента может быть расширена кодом, приходящим с сервера. Сейчас такое можно встретить повсеместно: JavaScript используется для «оживления» страниц и исполнения каких-то сценариев на стороне клиента. Но принципы формулировались в 2000 году — тогда исполняемый код с сервера возвращали не так часто. Потому и выделили это в отдельный принцип.

В терминах REST URL-адрес, идентифицирующий ресурс, принято называть эндпоинтом (англ. endpoint, «конечная точка»).
Почти всегда ресурсы именуют существительными во множественном числе

```html
/users 
/api/starships
```

Иногда для именования ресурсов применяют существительные в единственном числе:

```html
/users/{user-id}/profile
/users/me
```

Бытует мнение, что лучше избегать такого «висячего» слеша в конце URL — ведь он не добавляет информации.
Другое мнение заключается в том, что висячий слеш обязателен для любого ресурса, который может содержать дочерние элементы.

В URL не должно быть пробелов, их заменяют дефисами или нижними подчёркиваниями. Лучше применять дефисы

### HTTP-методы

Любой API предназначен для получения доступа к ресурсам. К ресурсу всегда можно обратиться по URL.
HTTP-метод запроса определяет, что следует сделать:
 - GET получает ресурсы;
 - POST создаёт ресурс;
 - PUT заменяет существующий ресурс целиком;
 - PATCH частично изменяет существующий ресурс;
 - DELETE удаляет ресурс.
Реже применяют ещё два метода:
 - HEAD получает только заголовки ответа. HEAD похож на GET, но в ответе на этот запрос есть только заголовок, а тела ответа нет.
 - OPTIONS получает перечень HTTP-методов, которые поддерживает сервер.

```
# Получить список пользователей
GET .../users

# Создать пользователя
POST .../users

# Удалить пользователя с id = 2
DELETE .../users/2 
```

### Идемпотентность и безопасность методов
У методов есть две характеристики — безопасность и идемпотентность.
Безопасность: если метод может изменить ресурс, то он считается небезопасным в терминах архитектуры REST. Такими методами могут быть PUT, PATCH, DELETE или POST.
Идемпотентность (от лат. idem — «тот же самый» и potens — «способный») — это свойство метода, заключающееся в том, что многократное выполнение этого метода по результату равно однократному. То есть, выполняя один и тот же запрос много-много раз, мы всегда будем получать один и тот же результат.

